BeginPackage["ResourceFunctions`ParticleDecayChain`"];
ComputeParticleDecayChainStructure;
HypergraphConstituents;
hypergraphPlotOptions;
ParticleDecayChain;
Begin["`Private`"]
Clear[ComputeParticleDecayChainStructure, HypergraphConstituents, hypergraphPlotOptions, ParticleDecayChain];
(* Generate data structure of particle decays in the form of nested associations. *)
Options[ComputeParticleDecayChainStructure] = {"DecaySteps" -> 2, "MinimumBranchingRatio" -> 0., "MaximumDecayModes" -> All};
ComputeParticleDecayChainStructure[particle_Entity, depth_, opts : OptionsPattern[]] :=
Module[
	{
		decayModes, keepDecayModes, sortedDecayModes, decayAssoc
	},
	decayModes = particle["DecayModes"];
	If[
		MissingQ[decayModes] || decayModes === <||> || AllTrue[decayModes, MissingQ], 
		Return[particle]
	];(* Stable particle or no known decays. *)
	If[depth >= OptionValue["DecaySteps"], Return[particle]]; (* Stop recursion based on depth. *)
	keepDecayModes = 
	ReverseSort[
		Select[
			decayModes, 
			If[Head[#] === Interval, #[[1, 2]], #] >= OptionValue["MinimumBranchingRatio"] &
		]
	]; (* Most likely decays first. *)
	If[
		Length[keepDecayModes] === 0,
		Return[particle]
	];
    sortedDecayModes = 
	Take[
		keepDecayModes, 
		Min[
			OptionValue["MaximumDecayModes"] /. All :> Infinity, 
			Length[keepDecayModes]
		]
	]; 
	decayAssoc =
	Association[
		particle ->
		Map[
			Function[
				{decayProduct},
				<|
					"DecayProducts" -> Map[ComputeParticleDecayChainStructure[#, depth + 1, opts] &, decayProduct], 
					(* Recursively call function at greater depth. *)
					"BranchingRatio" -> sortedDecayModes[decayProduct]
					(* BR are values of sortedDecayModes. *)
				|>
			],
			Keys[sortedDecayModes]
		]
	];
	decayAssoc
];

(* Traverse data structure generated by ComputeParticleDecayChainStructure to generate hyperedges and vertex labels. *)
HypergraphConstituents[chain_, label_] :=
Module[
	{
		particle, vertices = {}, hyperedges = {},
		decayModes, subVertices, subHyperedges,
		childCount = 1
	},
	If[
		MatchQ[chain, _Entity],
		Return[<|"Vertices" -> {label -> chain}, "Hyperedges" -> {}|>] (* Particles with no further decays. *)
	];
	particle = First[Keys[chain]];
	AppendTo[vertices, label -> particle];
	decayModes = chain[particle]; (* Extract decay modes from chain. *)
	Do[
		Block[
			{childLabels = {}},(* 
			Initialize label list for each decay mode. *)
			With[
				{decayProducts = mode["DecayProducts"]},
				Do[
					With[
						{childLabel = label <> "." <> ToString[childCount]}, (* Vertices are labelled by "ParentLabel.ChildCount". *)
						AppendTo[childLabels, childLabel];
						{subVertices, subHyperedges} = Values[HypergraphConstituents[decayProducts[[j]], childLabel][[{"Vertices", "Hyperedges"}]]]; 
						(* Recursively call function on each decay product, with new label. *)
						vertices = Join[vertices, subVertices];
						hyperedges = Join[hyperedges, subHyperedges];
						childCount++ (* Iterate through each decay product and increase counter each time. *)
					],
					{j, Length[decayProducts]}
				];
				If[
					Length[childLabels] > 0,
					AppendTo[hyperedges, Prepend[childLabels, label]] (* Include each hyperedge of parent and children. *)
				]
			]
		],
		{mode, decayModes}
	];
	<|"Vertices" -> vertices, "Hyperedges" -> hyperedges|> (* Return an association. *)
];

(* From ResourceFunction["HypergraphPlot"]. Changed default from "BaseLayout" and "SubsetBoundaryScale". *)
hypergraphPlotOptions =
{
	"BaseLayout" -> "RadialEmbedding", "SubsetBoundaryScale" -> 1, 
	"SubsetBoundary" -> Automatic, "SubsetBoundaryStyle" -> Automatic, 
	"SubsetEdge" -> Automatic, "SubsetEdgeStyle" -> Automatic,
	PlotTheme -> "NameLabeled", VertexCoordinates -> Automatic, 
	VertexLabels -> Automatic, VertexLabelStyle -> Automatic, 
	VertexShapeFunction -> Automatic, VertexSize -> 0.15, 
	VertexStyle -> Automatic
};

(* Combine functions above. *)
(* Whether to visualize the decay or just get the data. *)
Options[ParticleDecayChain] = Join[Options[ComputeParticleDecayChainStructure], hypergraphPlotOptions];
ParticleDecayChain[particle_Entity] := ComputeParticleDecayChainStructure[particle, 0]; (* Simplest case. *)
ParticleDecayChain[particle_Entity, hypergraph_String : "", opts : OptionsPattern[ParticleDecayChain]] :=
Module[
	{chain, vertices, hyperedges, vertexLabels},
	chain = ComputeParticleDecayChainStructure[particle, 0, FilterRules[{opts}, Options[ComputeParticleDecayChainStructure]]];
	If[
		TrueQ[hypergraph === "Hypergraph"],
		{vertices, hyperedges} = Values[HypergraphConstituents[chain, "1"][[{"Vertices", "Hyperedges"}]]]; (* Obtain vertex labels and hyperedges. *)
		vertexLabels = OptionValue[VertexLabels]; (* Get the user-defined VertexLabels option *)
		If[vertexLabels === None, vertexLabels = None, vertexLabels = vertices]; (* Default to vertices if not overridden *)
		ResourceFunction["HypergraphPlot"][
			hyperedges,
			FilterRules[
				Join[
					{opts},
					{
						"BaseLayout" -> OptionValue["BaseLayout"], 
						"SubsetBoundaryScale" -> OptionValue["SubsetBoundaryScale"], 
						VertexLabels -> vertexLabels
					}
				],
				hypergraphPlotOptions
			] (* Override defaults of ResourceFunction["HypergraphPlot"]. *)
		],
	chain (* Just return data structure if "Hypergraph" is not inputted. *)
	]
];
ParticleDecayChain[particle_, opts : OptionsPattern[]] := Message[ParticleDecayChain::invalid, particle];
(* Define the error message. *)
ParticleDecayChain::invalid = "The input `1` is not a valid particle Entity.";

End[]
EndPackage[]